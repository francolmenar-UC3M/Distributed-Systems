/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "user_storage.h"


/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "user_storage.h"
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <fcntl.h>
#include <sys/socket.h>
#include <sys/ioctl.h>
#include <netinet/in.h>
#include <net/if.h>
#include <arpa/inet.h>
#include "message.h"
#include <netdb.h>
#include <limits.h>

#include <unistd.h>
#include <string.h>
#include <errno.h>

#include "dlinkedlist.c"
#include "read_line.h"
#include "user_storage.h"
#include "user.h"
#include "message.h"
// #define FALSE 0 Allready defined somewhere
// #define TRUE 1

#define LISTEN_BACKLOG 50
#define MAX_LINE 256

int ext_register_user(char *username);
int userstorage_register(char *host, int *res_add);
int ext_unregister_user(char *username);
int userstorage_unregister(char *host, int *res_add);
int has_messages(char* username, int* has);
int ext_get_user(char* username, struct user* usr_add);
int get_last_message(char* username, struct message* mes);
int update_client(struct user* data, struct user* usr_add);

int process_data(int s_local, char* operation);
void* process_request(void* s);
int connect_user(int s_local, char* username);
int disconnect(char* username);
int unregister(char* username);
int send_message(char* sender, char* receiver, char* message);
int setMessage(char * str, char * dest);
int sendToClient(int socket, char * msg);

pthread_mutex_t mutex_msg;
pthread_mutex_t message_id_lock;
pthread_cond_t cond_msg;
int sock_not_free = 1;
char* host;

int sendToClient(int socket, char * msg){
    char  str [MAX_LINE];
    setMessage(msg, str);
    send(socket, str, MAX_LINE, MSG_NOSIGNAL);
    return 0;
}

int setMessage(char *str, char * dest){
    char msg[MAX_LINE];
    memset(msg, '\0', sizeof(msg));
    strcpy(msg, str);
    strcpy(dest, msg);
    return 0;
}

int main (int argc, char *argv[]){
  host ="user_storage_server";

	char* server_ip;
	int server_port;
	int server_socket, client_socket;
	struct sockaddr_in server, client;
	struct ifreq ifr;
	socklen_t peer_addr_size = sizeof(struct sockaddr_in);

	if (argc != 3 || strcmp(argv[1], "-p") != 0) {
		fprintf(stderr, "%s\n\n", "usage: ./server -p <port>");
		return -1;
	}


	    next_message_id = 1;

	    server_port = atoi(argv[2]);
	    server_socket = socket(AF_INET, SOCK_STREAM, 0); // Open socket

	    int val;
	    val = 1;
	    setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char *)&val, sizeof(int));

	    if (server_socket == -1) {
	      fprintf(stderr, "%s\n", "ERROR socket cannot be opened");
	      return -1;
	    }

	    bzero((char *)&ifr, sizeof(struct ifreq));
	    ifr.ifr_addr.sa_family = AF_INET; // Set family IPv4
	    //snprintf(ifr.ifr_name, IFNAMSIZ, "eth0");
	    snprintf(ifr.ifr_name, IFNAMSIZ, "lo"); // TODO: Default network interface
	    ioctl(server_socket, SIOCGIFADDR, &ifr);
	    server_ip = inet_ntoa(((struct sockaddr_in *)&ifr.ifr_addr)->sin_addr);
	    /**********************************************/

	    bzero((char *)&server, sizeof(struct sockaddr_in));
	    server.sin_family = AF_INET;
	    if (inet_aton(server_ip, &server.sin_addr) == 0) {
	      fprintf(stderr, "%s\n", "ERROR invalid IP address");
	      return -1;
	    }
	    server.sin_port = htons(server_port);

	    if (bind(server_socket, (struct sockaddr *) &server, sizeof(struct sockaddr_in)) == -1) {
	      fprintf(stderr, "%s\n", "ERROR binding failed");
	      return -1;
	    }

	    if (listen(server_socket, LISTEN_BACKLOG) == -1) {
	      fprintf(stderr, "%s\n", "ERROR listening failed");
	      return -1;
	    }

	    pthread_attr_t t_attr;
	    pthread_mutex_init(&mutex_msg, NULL);
	    pthread_mutex_init(&message_id_lock, NULL);
	    pthread_cond_init(&cond_msg, NULL);
	    pthread_attr_init(&t_attr);
	    pthread_attr_setdetachstate(&t_attr, PTHREAD_CREATE_DETACHED);

	    pthread_t thr;

	    printf("s> init server %s:%d\n", server_ip, server_port);
	    printf("s> ");

	    while(TRUE) {

	      bzero((char *)&client, sizeof(struct sockaddr_in));
	      client_socket = accept(server_socket, (struct sockaddr *)&client, &peer_addr_size);
	      pthread_create(&thr, &t_attr, &process_request, (void *)&client_socket);

	      pthread_mutex_lock(&mutex_msg);
	      while(sock_not_free) {
	        pthread_cond_wait(&cond_msg, &mutex_msg);
	      }
	      sock_not_free = TRUE;
	      pthread_mutex_unlock(&mutex_msg);

	    }

	// char *host;
	//
	// if (argc < 2) {
	// 	printf ("usage: %s server_host\n", argv[0]);
	// 	exit (1);
	// }
	// host = argv[1];

  //Llamar desde cada funcion?????
  //userstorage_1 (host);

	exit (0);
}


void* process_request(void* s) {
  int s_local;
  char return_code;
  int error;

  pthread_mutex_lock(&mutex_msg);
  s_local = *(int*)s;
  sock_not_free = FALSE;
  pthread_cond_signal(&cond_msg);
  pthread_mutex_unlock(&mutex_msg);

  char operation[MAX_LINE];
  bzero(operation, MAX_LINE);
  if (readLine(s_local, operation, MAX_LINE) == -1) {
    fprintf(stderr, "ERROR reading line\n");
    error = -2;
    pthread_exit(&error);
  }

  return_code = process_data(s_local, operation);

  send(s_local, &return_code, 1, MSG_NOSIGNAL);

  /* If we are sending a message, we also return to the sender the message id */
  if(strcmp(operation, "SEND\0") == 0){
    char id_toClient[MAX_LINE];
    sprintf(id_toClient, "%u", (next_message_id-1));
    sendToClient(s_local, id_toClient);
  }
  close(s_local);
  pthread_exit(0);

  return 0;
}


int process_data(int s_local, char* operation) {
  char argument1[MAX_LINE];

  if (readLine(s_local, argument1, MAX_LINE) == -1) {
    fprintf(stderr, "ERROR reading line\n");
    return 2;
  }

  if (operation == NULL || argument1 == NULL) {
    printf("s> ERROR MESSAGE FORMAT\n");
    return 2;
  }

  if (strcmp(operation, "REGISTER\0") == 0) {
		int reg = ext_register_user(argument1);
		if(reg < 0){
			printf("ERROR in ext_register_user\n");
		}
    return reg;

  } else if (strcmp(operation, "UNREGISTER\0") == 0) {
		int reg = ext_unregister_user(argument1);
		if(reg < 0){
			printf("ERROR in ext_unregister_user\n");
		}
    return reg;

  } else if (strcmp(operation, "CONNECT\0") == 0) {
    return connect_user(s_local, argument1);

  } else if (strcmp(operation, "DISCONNECT\0") == 0) {
    return disconnect(argument1);

  } else if (strcmp(operation, "SEND\0") == 0) {
    printf("entro\n");
    char argument2[MAX_LINE];
    if (readLine(s_local, argument2, MAX_LINE) == -1) {
      fprintf(stderr, "ERROR reading line\n");
      return 2;
    }
    char argument3[MAX_LINE];
    if (readLine(s_local, argument3, MAX_LINE) == -1) {
      fprintf(stderr, "ERROR reading line\n");
      return 2;
    }

    printf("OP: %s\n", operation);
    printf("ARG1: %s\n", argument1);
    printf("ARG2: %s\n", argument2);
    printf("ARG3: %s\n", argument3);

    return send_message(argument1, argument2, argument3);

  } else {
    fprintf(stderr, "s> ERROR MESSAGE FORMAT");
    return 2;
  }
  return 0;
}


int ext_register_user(char *username) {
	int res = 0;
	userstorage_register(username, &res);
	printf("Back from registering %s\n", username);
  return res;
}


int userstorage_register(char* username, int *res_add) {
	CLIENT *clnt;
	enum clnt_stat retval_1;
	int res = 0;
#ifndef	DEBUG
	clnt = clnt_create (host, USERSTORAGE, USERSTORAGEVER, "TCP");
	if (clnt == NULL) {
		clnt_pcreateerror (host);
		exit (1);
	}
#endif	/* DEBUG */

	retval_1 = register_user_1(username, res_add, clnt);
	if (retval_1 != RPC_SUCCESS) {
		clnt_perror (clnt, "call failed");
	}

#ifndef	DEBUG
	clnt_destroy (clnt);
#endif	 /* DEBUG */
	return res;
}


int ext_unregister_user(char *username) {
	int res = 0;
	userstorage_unregister(username, &res);
	printf("Back from UNregistering %s\n", username);
  return res;
}

int userstorage_unregister(char* username, int *res_add) {
	CLIENT *clnt;
	enum clnt_stat retval_1;
	int res = 0;
#ifndef	DEBUG
	clnt = clnt_create (host, USERSTORAGE, USERSTORAGEVER, "TCP");
	if (clnt == NULL) {
		clnt_pcreateerror (host);
		exit (1);
	}
#endif	/* DEBUG */

	retval_1 = unregister_user_1(username, res_add, clnt);
	if (retval_1 != RPC_SUCCESS) {
		clnt_perror (clnt, "call failed");
	}

#ifndef	DEBUG
	clnt_destroy (clnt);
#endif	 /* DEBUG */
	return res;
}


int connect_user(int s_local, char* username){

  struct sockaddr_in client_addr;
  socklen_t size;
  size = sizeof(struct sockaddr_in);
  getpeername(s_local, (struct sockaddr *)&client_addr, &size);

  struct user *user_node;
  //user_node = search(username);
	//TODO
	if(ext_get_user(username, user_node) < 0){
		printf("ERROR IN ext_get_user\n");
		return 0;
	}

  //User does not exist
  if(user_node == NULL){
    printf("CONNECT %s FAIL\n", username);
    return 1;
  }
  //User is already connected
  if(user_node->status != 0){
    printf("CONNECT %s FAIL\n", username);
    return 2;
  }
  else{ //User is disconnected

    //Filling the data for the user node to be connected
    struct user *data_connected = (struct user*) malloc(sizeof(struct user));
    strcpy(data_connected->username, username);
		//Status now is "connected"
    data_connected->status = TRUE;
    data_connected->ip_address = &client_addr.sin_addr;

    char argument2[MAX_LINE];
    if (readLine(s_local, argument2, MAX_LINE) == -1) {
      fprintf(stderr, "ERROR reading line\n");
      return 2;
    }
    data_connected->port = atoi(argument2);
    data_connected->pending_messages = user_node->pending_messages;

    //Create the updated node with the data previously filled
    //struct Node *user_connected = getNewNode(data_connected);
    //Update node
    //modify(user_connected);

		//TODO
		struct user *user_connected = (struct user*) malloc(sizeof(struct user));
		if(update_client(data_connected, user_connected) < 0){
			printf("ERROR in update_client\n");
			return -1;
		}

    printf("CONNECT %s OK\n", username);
    printf("CHECKING PENDING MESSAGES\n");

		//TODO
    //if(isEmpty(user_connected->pending_messages) == 0){
		int checkQueue = 0;
		if(has_messages(user_connected->username, &checkQueue) < 0){
			printf("ERROR in user_connected\n");
			return -1;
		}

	  if(checkQueue == 1){
			printf("%s HAS PENDING MESSAGES\n", user_connected->username);

      //Preparing the socket to provide results
      int sd;
      struct sockaddr_in receiver_client;

      char msg_id_in_char[11];
      char * send_message = "SEND_MESSAGE";


      //while(isEmpty(user_connected->pending_messages) != 1){
			while(checkQueue == 1){
        sd = socket(AF_INET, SOCK_STREAM, 0);
        if (sd == -1) {
          /* fprintf(stderr, "%s\n", "s> Could not create socket");*/
          return 3;
        }

        bzero((char *)&receiver_client, sizeof(struct sockaddr_in));
        memcpy(&(receiver_client.sin_addr), user_connected->ip_address, sizeof(struct in_addr));
        receiver_client.sin_family = AF_INET;
        receiver_client.sin_port = htons(user_connected->port);

        if (connect(sd, (struct sockaddr *)&receiver_client, sizeof(struct sockaddr_in)) < 0) {
          return 3;
        }

        //NODE *queue_message = Dequeue(user_connected->data->pending_messages);
				struct message *mes = (struct message*) malloc(sizeof(struct message));
				//TODO
				if(get_last_message(user_connected->username, mes) < 0){ //dequeue but in distributed server
					printf("ERROR in get_last_message\n");
					return -1;
				}


        sprintf(msg_id_in_char, "%u", mes->id);

        sendToClient(sd, send_message);
        sendToClient(sd, mes->from_user);
        sendToClient(sd, msg_id_in_char);
        sendToClient(sd, mes->text);

        close(sd);

        printf("SEND MESSAGE %d FROM %s TO %s\n", mes->id, mes->from_user, user_connected->username);
				if(has_messages(user_connected->username, &checkQueue)){
					printf("ERROR in has_messages\n");
					return -1;
				}
      }
    }
  }
  return 0;
}



int ext_get_user(char* username, struct user* usr_add) {
	CLIENT *clnt;
	enum clnt_stat retval_1;
	int res = 0;
#ifndef	DEBUG
	clnt = clnt_create (host, USERSTORAGE, USERSTORAGEVER, "TCP");
	if (clnt == NULL) {
		clnt_pcreateerror (host);
		exit (1);
	}
#endif	/* DEBUG */
	retval_1 = get_user_1(username, usr_add, &res,clnt);
	if (retval_1 != RPC_SUCCESS) {
		clnt_perror (clnt, "call failed");
	}

#ifndef	DEBUG
	clnt_destroy (clnt);
#endif	 /* DEBUG */
	return res;
}


int update_client(struct user* data, struct user* usr_add) {
	CLIENT *clnt;
	enum clnt_stat retval_1;
	int res = 0;
#ifndef	DEBUG
	clnt = clnt_create (host, USERSTORAGE, USERSTORAGEVER, "TCP");
	if (clnt == NULL) {
		clnt_pcreateerror (host);
		exit (1);
	}
#endif	/* DEBUG */
	retval_1 = update_client_1(data, usr_add, &res,clnt);
	if (retval_1 != RPC_SUCCESS) {
		clnt_perror (clnt, "call failed");
	}

#ifndef	DEBUG
	clnt_destroy (clnt);
#endif	 /* DEBUG */
	return res;
}


int get_last_message(char* username, struct message* mes) {
	CLIENT *clnt;
	enum clnt_stat retval_1;
	int res = 0;
#ifndef	DEBUG
	clnt = clnt_create (host, USERSTORAGE, USERSTORAGEVER, "TCP");
	if (clnt == NULL) {
		clnt_pcreateerror (host);
		exit (1);
	}
#endif	/* DEBUG */
	retval_1 = get_last_message_1(username, mes, &res, clnt);
	if (retval_1 != RPC_SUCCESS) {
		clnt_perror (clnt, "call failed");
	}

#ifndef	DEBUG
	clnt_destroy (clnt);
#endif	 /* DEBUG */
	return res;
}


int has_messages(char* username, int* has) {
	CLIENT *clnt;
	enum clnt_stat retval_1;
	int res = 0;
#ifndef	DEBUG
	clnt = clnt_create (host, USERSTORAGE, USERSTORAGEVER, "TCP");
	if (clnt == NULL) {
		clnt_pcreateerror (host);
		exit (1);
	}
#endif	/* DEBUG */
	retval_1 = has_messages_1(username, has, &res, clnt);
	if (retval_1 != RPC_SUCCESS) {
		clnt_perror (clnt, "call failed");
	}

#ifndef	DEBUG
	clnt_destroy (clnt);
#endif	 /* DEBUG */
	return res;
}




//CODIGO GENERADO ORIGINALMENTE NO BORRAR POR SI SE LIA PARDA
// void
// userstorage_1(char *host)
// {
// 	CLIENT *clnt;
// 	enum clnt_stat retval_1;
// 	int result_1;
// 	enum clnt_stat retval_2;
// 	int result_2;
// 	char register_user_1_username;
// 	enum clnt_stat retval_3;
// 	int result_3;
// 	char unregister_user_1_username;
// 	enum clnt_stat retval_4;
// 	int result_4;
// 	char get_user_1_username;
// 	struct user  get_user_1_usr;
// 	enum clnt_stat retval_5;
// 	int result_5;
// 	struct message add_message_1_msg;
// 	enum clnt_stat retval_6;
// 	int result_6;
// 	char get_total_messages_1_username;
// 	enum clnt_stat retval_7;
// 	int result_7;
// 	char get_message_1_username;
// 	u_int  get_message_1_msg_id;
// 	char get_message_1_md5;
// 	struct message get_message_1_msg;
//
// #ifndef	DEBUG
// 	clnt = clnt_create (host, USERSTORAGE, USERSTORAGEVER, "udp");
// 	if (clnt == NULL) {
// 		clnt_pcreateerror (host);
// 		exit (1);
// 	}
// #endif	/* DEBUG */
//
// 	retval_1 = init_1(&result_1, clnt);
// 	if (retval_1 != RPC_SUCCESS) {
// 		clnt_perror (clnt, "call failed");
// 	}
// 	retval_2 = register_user_1(register_user_1_username, &result_2, clnt);
// 	if (retval_2 != RPC_SUCCESS) {
// 		clnt_perror (clnt, "call failed");
// 	}
// 	retval_3 = unregister_user_1(unregister_user_1_username, &result_3, clnt);
// 	if (retval_3 != RPC_SUCCESS) {
// 		clnt_perror (clnt, "call failed");
// 	}
// 	retval_4 = get_user_1(get_user_1_username, get_user_1_usr, &result_4, clnt);
// 	if (retval_4 != RPC_SUCCESS) {
// 		clnt_perror (clnt, "call failed");
// 	}
// 	retval_5 = add_message_1(add_message_1_msg, &result_5, clnt);
// 	if (retval_5 != RPC_SUCCESS) {
// 		clnt_perror (clnt, "call failed");
// 	}
// 	retval_6 = get_total_messages_1(get_total_messages_1_username, &result_6, clnt);
// 	if (retval_6 != RPC_SUCCESS) {
// 		clnt_perror (clnt, "call failed");
// 	}
// 	retval_7 = get_message_1(get_message_1_username, get_message_1_msg_id, get_message_1_md5, get_message_1_msg, &result_7, clnt);
// 	if (retval_7 != RPC_SUCCESS) {
// 		clnt_perror (clnt, "call failed");
// 	}
// #ifndef	DEBUG
// 	clnt_destroy (clnt);
// #endif	 /* DEBUG */
// }
//
//
// int
// main (int argc, char *argv[])
// {
// 	char *host;
//
// 	if (argc < 2) {
// 		printf ("usage: %s server_host\n", argv[0]);
// 		exit (1);
// 	}
// 	host = argv[1];
// 	userstorage_1 (host);
// exit (0);
// }
