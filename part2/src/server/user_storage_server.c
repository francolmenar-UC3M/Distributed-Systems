/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include <pthread.h>

#include "user_storage.h"

#include "queue.h"
#include "dlinkedlist.h"

Node* head_users;
Node* head_messages;

unsigned int next_message_id;

pthread_mutex_t message_id_lock;

int *
init_1_svc(struct svc_req *rqstp)
{
	static int  result;

	pthread_mutex_init(&message_id_lock, NULL);
	next_message_id = 0;

	destroyList(head_users);
	destroyList(head_messages);

	result = 0;

	return &result;
}

int *
register_user_1_svc(char *username,  struct svc_req *rqstp)
{
	static int  result;

	if (search_user(head_users, username) != NULL) {
		printf("s> REGISTER %s FAIL\n", username);
		result = 1;
		// return 1;
		return &result;
	} else {
		struct user *new_user = (struct user*)malloc(sizeof(struct user));
		strcpy(new_user->username, username);
		new_user->status = 0;
		new_user->ip_address = 0;
		new_user->port = 0;
		new_user->pending_messages = ConstructQueue(10);
		new_user->last_message = 0;

		Node* new_node = getNewNode((void*)new_user);
		insert_user(head_users, new_node);
		printf("s> REGISTER %s OK\n", username);
	}
	// return 0;
	result = 0;

	return &result;
}

int *
unregister_user_1_svc(char *username,  struct svc_req *rqstp)
{
	static int  result;

	/* Succesful unregister */
  if(delete_user(head_users, username) == 0){
    printf("s> UNREGISTER %s OK\n", username);
    // return 0;
		result = 0;
		return &result;
  }
  /* ERROR: user is not found in the data structure */
  else if(delete_user(head_users, username) == -1){
    printf("s> UNREGISTER %s FAIL\n", username);
    // return 1;
		result = 1;
		return &result;
  }
  /* ERROR: any other case */
  else{
    printf("s> UNREGISTER %s FAIL\n", username);
    // return 2;
		result = 2;
		return &result;
  }

	return &result;
}

struct user *
get_user_1_svc(char *username,  struct svc_req *rqstp)
{
	static struct user  result;

	struct Node *user_node;
	user_node = search_user(head_users, username);

	if (user_node == NULL) {
		return NULL;
	} else {
		result = *(struct user*)user_node->data;
		return &result;
	}

	return &result;
}

int *
add_message_1_svc(struct message msg,  struct svc_req *rqstp)
{
	static int  result;

	if ((strlen(msg.text)+1) > MAXSIZE) {
	 result = 2;
	 return &result;
	}

	Node* senderNode = search_user(head_users, msg.from_user);
	Node* receiverNode = search_user(head_users, msg.to_user);

	if((senderNode == NULL) || (receiverNode == NULL)) {
		result = 1;
		return &result;
	}

	if (((struct user*)senderNode->data)->status == 0) {
		 result = 2;
		 return &result;
	}

	NODE *receiver_message = malloc(sizeof(NODE));
	receiver_message->data.mes = &msg;

	insert_msg(head_messages, (void*)&msg);

	Enqueue(((struct user*)receiverNode->data)->pending_messages, receiver_message);
	result = 0;

	return &result;
}

int *
get_total_messages_1_svc(char *username,  struct svc_req *rqstp)
{
	static int  result;

	int count = 0;
 	count = get_total_messages_by_user(head_messages, username);
 	result = count;

	return &result;
}

struct message *
get_message_1_svc(char *username, u_int msg_id,  struct svc_req *rqstp)
{
	static struct message  result;

	 Node* mesg;
	 mesg = search_msg(head_messages, msg_id);

	 if (mesg == NULL) {
		return NULL;
	 }

	 /* cALCULATE MD5*/
	 /* strcpy(md5, md5calculated) */
	 result = *(struct message*)mesg->data;

	return &result;
}
