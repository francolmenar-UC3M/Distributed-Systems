/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "user_storage.h"
#include "dlinkedlist.c"
#include "queue.c"

#include "message.h"
#include "user.h"

bool_t
init_1_svc(int *result, struct svc_req *rqstp)
{
	bool_t retval;

	/*
	 * insert server code here
	 */
	 *result = 0;

	return retval;
}

bool_t
register_user_1_svc(char *username, int *result,  struct svc_req *rqstp)
{
	bool_t retval;

	 if (search(username) != NULL) {
     printf("s> REGISTER %s FAIL\n", username);
		 *result = 1;
     // return 1;
		 return retval;
   } else {
     struct user *new_user = (struct user*)malloc(sizeof(struct user));
     strcpy(new_user->username, username);
     new_user->status = 0;
     new_user->ip_address = NULL;
     new_user->port = 0;
     new_user->pending_messages = ConstructQueue(10);
     new_user->last_message = 0;

     Node* new_node = getNewNode(new_user);
     insert(new_node);
     printf("s> REGISTER %s OK\n", username);
   }
   // return 0;
	 *result = 0;

	return retval;
}

bool_t
unregister_user_1_svc(char *username, int *result,  struct svc_req *rqstp)
{
	bool_t retval;

	/* Succesful unregister */
  if(delete(username) == 0){
    printf("s> UNREGISTER %s OK\n", username);
    // return 0;
		*result = 0;
		return retval;
  }
  /* ERROR: user is not found in the data structure */
  else if(delete(username) == -1){
    printf("s> UNREGISTER %s FAIL\n", username);
    // return 1;
		*result = 1;
		return retval;
  }
  /* ERROR: any other case */
  else{
    printf("s> UNREGISTER %s FAIL\n", username);
    // return 2;
		*result = 2;
		return retval;
  }

	return retval;
}

bool_t
get_user_1_svc(char *username, struct user *usr, int *result,  struct svc_req *rqstp)
{
	bool_t retval;

	struct Node *user_node;
	user_node = search(username);

	if (user_node == NULL) {
		*result = 1;
		free(user_node);
		return retval;
	} else {
		memcpy(usr, user_node->data, sizeof(struct user));
		*result = 0;
		free(user_node);
		return retval;
	}

	return retval;
}

bool_t
add_message_1_svc(struct message msg, int *result,  struct svc_req *rqstp)
{
	bool_t retval;

	 if ((strlen(msg.text)+1) > MAX_LINE) {
	 	*result = 2;
		return retval;
	 }

	 Node* senderNode = search(msg.from_user);
	 Node* receiverNode = search(msg.to_user);

	 if((senderNode == NULL) || (receiverNode == NULL)) {
		 *result = 1;
		 return retval;
	 }

	 if (senderNode->data->status == 0) {
	 		*result = 2;
			return retval;
	 }

	 NODE *receiver_message = malloc(sizeof(NODE));
	 receiver_message->data.mes = &msg;

	 Enqueue(receiverNode->data->pending_messages, receiver_message);
	 *result = 0;

	return retval;
}

bool_t
get_total_messages_1_svc(char *username, int *result,  struct svc_req *rqstp)
{
	bool_t retval;

	/*
	 * insert server code here
	 */



	return retval;
}

bool_t
get_message_1_svc(char *username, u_int msg_id, char *md5, struct message *msg, int *result,  struct svc_req *rqstp)
{
	bool_t retval;

	/*
	 * insert server code here
	 */

	return retval;
}

int
userstorage_1_freeresult (SVCXPRT *transp, xdrproc_t xdr_result, caddr_t result)
{
	xdr_free (xdr_result, result);

	/*
	 * Insert additional freeing code here, if needed
	 */

	return 1;
}
